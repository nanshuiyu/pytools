<?xml version="1.0" encoding="utf-8" ?>
<!--
  Copyright (c) Microsoft Corporation.

  This source code is subject to terms and conditions of the Apache License, Version 2.0. A
  copy of the license can be found in the License.html file at the root of this distribution. If
  you cannot locate the Apache License, Version 2.0, please send an email to
  vspython@microsoft.com. By using this source code in any fashion, you are agreeing to be bound
  by the terms of the Apache License, Version 2.0.
 
  You must not remove this notice, or any other, from this software.
-->
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0">
  <!-- *************************************************************************
       Azure publishing support.
  -->
  <PropertyGroup>
    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
    <_AzureSupportPath Condition="'$(_AzureSupportPath)' == ''">$(MSBuildThisFileDirectory)</_AzureSupportPath>
    <_AzureSupportPath Condition="!HasTrailingSlash('$(_AzureSupportPath)')">$(_AzureSupportPath)\</_AzureSupportPath>
    <_WebPISupportPath Condition="'$(_WebPISupportPath)' == ''">$(_AzureSupportPath)</_WebPISupportPath>
    <_WebPISupportPath Condition="!HasTrailingSlash('$(_WebPISupportPath)')">$(_WebPISupportPath)\</_WebPISupportPath>
  </PropertyGroup>

  <!-- Build is only enabled if CoreCompile is defined. -->
  <Target Name="CoreCompile" />

  <!-- These targets are required to satisfy the Web publishing targets. -->
  <Target Name="GetTargetFrameworkVersion" Returns="v4.0" />
  <Target Name="GetTargetFrameworkDirectories" Returns="" />
  <Target Name="GetTargetFrameworkMoniker" Returns="" />
  <Target Name="GetTargetFrameworkMonikerDisplayName" Returns="" />

  <Target Name="GenerateManifests" Returns="" />
  <Target Name="AddDatabasesToSourceManifest" Returns="" />
  <Target Name="CreateManifestResourceNames" Returns="" />

  <Target Name="WatGetTargetFrameworkDirectories" Returns=""  />
  <Target Name="BuiltProjectOutputGroupDependencies" Returns=""  />
  <Target Name="WatGetTargetFrameworkMoniker" Returns="" />
  <Target Name="WatGetTargetFrameworkMonikerDisplayName" Returns=""  />

  <Import Project="Microsoft.PythonTools.targets"/>
  <Import Project="$(VSToolsPath)\WebApplications\Microsoft.WebApplication.targets" />

  <!-- *************************************************************************
       Targets files for specific frameworks can schedule their own targets to
       be dependencies of ResolvePythonWsgiHandler to set the value of
       $(PythonWsgiHandler) at build time.
       
       Alternatively, the value of $(PythonWsgiHandler) can be set directly,
       using {StartupModule} to refer to the importable name of the start file.
  -->
  <PropertyGroup>
    <ResolvePythonWsgiHandlerDependsOnTargets>
      $(ResolvePythonWsgiHandlerDependsOnTargets)
    </ResolvePythonWsgiHandlerDependsOnTargets>
  </PropertyGroup>

  <Target Name="ResolvePythonWsgiHandler" DependsOnTargets="$(ResolvePythonWsgiHandlerDependsOnTargets)">
    <PropertyGroup Condition="'$(PythonWsgiHandler)' != ''">
      <PythonWsgiHandler>$(PythonWsgiHandler.Replace(`{StartupModule}`, $(StartupModule)))</PythonWsgiHandler>
    </PropertyGroup>
  </Target>

  <!-- *************************************************************************
       The Build target is invoked as part of the Publish phase.
  -->

  <PropertyGroup>
    <SkipCopyBuildProduct>true</SkipCopyBuildProduct>

    <PipelineCollectFilesPhaseDependsOn>
      $(PipelineCollectFilesPhaseDependsOn);
      CreateWebConfig;
      CollectPythonSourceFiles;
      CollectPythonWebSitesFiles;
      CollectPythonCloudServiceFiles;
      CollectVirtualEnvFiles
    </PipelineCollectFilesPhaseDependsOn>
  </PropertyGroup>

  <Target Name="CollectPythonSourceFiles">
    <ItemGroup>
      <FilesForPackagingFromProject Include="@(Compile)">
        <DestinationRelativePath>%(Compile.RelativeDir)%(Compile.Filename)%(Compile.Extension)</DestinationRelativePath>
        <FromTarget>CollectPythonSourceFiles</FromTarget>
        <Category>Run</Category>
      </FilesForPackagingFromProject>
    </ItemGroup>
  </Target>

  <!-- *************************************************************************
       The AllProjectOutputGroups target is invoked by the IDE when determining
       whether the project needs to be rebuilt.
  -->

  <PropertyGroup>
    <AllProjectOutputGroupsDependsOn>
      _BuildingForUpToDateCheck;
      ResolvePythonDeploymentMethod;
      _DetectWebConfig;
      _GetPythonWebSitesFiles;
      _GetPythonCloudServiceFiles;
      _GetPythonVirtualEnvProxyForEmulator;
      _GetPythonAzureSetupConfigOutput
    </AllProjectOutputGroupsDependsOn>

    <BuildingForUpToDateCheck>false</BuildingForUpToDateCheck>
  </PropertyGroup>

  <Target Name="_BuildingForUpToDateCheck">
    <PropertyGroup>
      <BuildingForUpToDateCheck>true</BuildingForUpToDateCheck>
    </PropertyGroup>
  </Target>

  <Target Name="AllProjectOutputGroups" DependsOnTargets="$(AllProjectOutputGroupsDependsOn)">
    <ItemGroup>
      <SourceFilesProjectOutputGroupOutput Include="@(Compile);@(Content);$(MSBuildProjectFullPath)" />

      <!-- If the project includes web.config, but we are going to regenerate
           it, we need to exclude it from our source files. -->
      <SourceFilesProjectOutputGroupOutput Remove="**\web.config" Condition="$(_RegenerateWebConfig)" />

      <BuiltProjectOutputGroupOutput Remove="@(BuiltProjectOutputGroupOutput)" />
      <BuiltProjectOutputGroupOutput Include="@(_PythonWebSitesFiles)" />
      <BuiltProjectOutputGroupOutput Include="@(_PythonCloudServiceFiles);@(_PythonCloudServiceFilesForEmulator)" />
      <BuiltProjectOutputGroupOutput Include="@(_PythonVirtualEnvProxyForEmulator)" />
      <BuiltProjectOutputGroupOutput Include="@(_PythonAzureSetupConfigOutput)" />

      <!-- The common targets invents a symbols file for our project, which will
           never be created. -->
      <DebugSymbolsProjectOutputGroupOutput Remove="@(DebugSymbolsProjectOutputGroupOutput)" />
    </ItemGroup>

    <!-- Finished checking, so reset this flag in case whoever is building us
         immediately starts running an actual build. -->
    <PropertyGroup>
      <BuildingForUpToDateCheck>false</BuildingForUpToDateCheck>
    </PropertyGroup>
  </Target>

  <!-- *************************************************************************
       ResolvePythonInterpreterPath finds and sets values based on the project's
       active environment. Interesting properties that are set include:
          PythonInterpreterPath (either python.exe/pythonw.exe or equivalent)
          VirtualEnvEnabled (true/false)
          PythonMajorVersion (2 or 3)
          PythonMinorVersion (0 through 9)
  -->
  <PropertyGroup>
    <!-- Setting default values in case targets that require them are invoked
         without invoking ResolvePythonInterpreterPath (for example, when
         checking whether we are up to date without any interpreters installed).
    -->
    <VirtualEnvEnabled>false</VirtualEnvEnabled>
    <VirtualEnvIsVEnv>false</VirtualEnvIsVEnv>
  </PropertyGroup>
  
  <Target Name="ResolvePythonInterpreterPath">
    <ResolveEnvironment>
      <Output TaskParameter="PrefixPath" PropertyName="PythonPrefixPath" />
      <Output TaskParameter="ProjectRelativePrefixPath" PropertyName="PythonPrefixSubPath" />
      <Output TaskParameter="InterpreterPath" PropertyName="PythonInterpreterPath" Condition="$(IsWindowsApplication) != 'true'" />
      <Output TaskParameter="WindowsInterpreterPath" PropertyName="PythonInterpreterPath" Condition="$(IsWindowsApplication) == 'true'" />
      <Output TaskParameter="Description" PropertyName="PythonInterpreterDescription" />
      <Output TaskParameter="MajorVersion" PropertyName="PythonMajorVersion" />
      <Output TaskParameter="MinorVersion" PropertyName="PythonMinorVersion" />
      <Output TaskParameter="Architecture" PropertyName="PythonArchitecture" />
      <Output TaskParameter="PathEnvironmentVariable" PropertyName="PythonPathEnvironmentVariable" />
    </ResolveEnvironment>

    <Error Text="Unable to resolve local Python environment" Condition="'$(PythonInterpreterPath)'==''" />

    <PropertyGroup>
      <PythonVersion>$(PythonMajorVersion).$(PythonMinorVersion)</PythonVersion>
    </PropertyGroup>
    
    <PropertyGroup Condition="'$(PythonPrefixSubPath)' == ''">
      <VirtualEnvEnabled>false</VirtualEnvEnabled>
      <VirtualEnvIsVEnv>false</VirtualEnvIsVEnv>
    </PropertyGroup>
    <PropertyGroup Condition="'$(PythonPrefixSubPath)' != ''">
      <VirtualEnvEnabled>true</VirtualEnvEnabled>
      <VirtualEnvIsVEnv Condition="Exists('$(PythonPrefixSubPath)Lib\orig-prefix.txt')">false</VirtualEnvIsVEnv>
      <VirtualEnvIsVEnv Condition="Exists('$(PythonPrefixSubPath)pyvenv.cfg')">true</VirtualEnvIsVEnv>
      <PythonPrefixSubPath Condition="!HasTrailingSlash('$(PythonPrefixSubPath)')">$(PythonPrefixSubPath)\</PythonPrefixSubPath>
    </PropertyGroup>

    <Error Text="A virtual environment is active, but cannot be resolved (orig-prefix.txt or pyvenv.cfg files were not found)."
           Condition="$(VirtualEnvEnabled) and '$(VirtualEnvIsVenv)' == ''" />
  </Target>

  <!-- *************************************************************************
       ResolveDeploymentSettings determines values for the following properties:
          DeployedPythonInterpreterPath
          DeployedSiteRoot
          DeployedWFastCgiPath
       
       It also executes ResolvePythonDeploymentMethod, which will ensure that
       _PythonDeploymentMethod is set to 'WebDeploy' or 'CloudServiceDeploy'.
       
       The _HostDeployDetectTarget should only be executed implicitly, or the
       value of _PythonDeploymentMethod may be incorrect.
  -->

  <Target Name="_HostDeployDetectTarget" BeforeTargets="GenerateGlobalPublishSetting">
    <PropertyGroup>
      <!-- We are deploying via web deploy to Microsoft Azure Web Sites -->
      <_PythonDeploymentMethod>WebDeploy</_PythonDeploymentMethod>
    </PropertyGroup>
  </Target>

  <Target Name="ResolvePythonDeploymentMethod" AfterTargets="_HostDeployDetectTarget">
    <PropertyGroup Condition="'$(_PythonDeploymentMethod)' == ''">
      <_PythonDeploymentMethod>CloudServiceDeploy</_PythonDeploymentMethod>
    </PropertyGroup>

    <Message Text="Deploying with $(_PythonDeploymentMethod)" Condition="!$(BuildingForUpToDateCheck)" />
  </Target>

  <Target Name="ResolveDeploymentSettings" DependsOnTargets="ResolvePythonDeploymentMethod">
    <!-- Set the deployment locations assuming deployment to Web Sites, user
         could override these in the project file
    -->
    <PropertyGroup Condition="'$(_PythonDeploymentMethod)' == 'WebDeploy'">
      <DeployedPythonInterpreterPath Condition="'$(DeployedPythonInterpreterPath)' == ''">D:\Python27\python.exe</DeployedPythonInterpreterPath>
      <DeployedSiteRoot Condition="'$(DeployedSiteRoot)' == ''">D:\home\site\wwwroot</DeployedSiteRoot>
      <DeployedWFastCgiPath Condition="'$(DeployedWFastCgiPath)' == ''">D:\Python27\Scripts\wfastcgi.py</DeployedWFastCgiPath>
    </PropertyGroup>

    <!-- Setup default deployment values if none have yet been provided. These
         assume the values will be replaced (typically by AzureSetup.exe) on the
         deployment.
    -->
    <PropertyGroup>
      <DeployedPythonInterpreterPath Condition="'$(DeployedPythonInterpreterPath)' == ''">%INTERPRETERPATH%</DeployedPythonInterpreterPath>
      <DeployedSiteRoot Condition="'$(DeployedSiteRoot)' == ''">%RootDir%</DeployedSiteRoot>
      <DeployedWFastCgiPath Condition="'$(DeployedWFastCgiPath)' == ''">%WFASTCGIPATH%</DeployedWFastCgiPath>
    </PropertyGroup>

    <Message Text="Deployed site root is $(DeployedSiteRoot)" Condition="!$(BuildingForUpToDateCheck)"/>
    <Message Text="Deployed WFastCgi path is $(DeployedWFastCgiPath)" Condition="!$(BuildingForUpToDateCheck)"/>
    <Message Text="Deployed Python path is $(DeployedPythonInterpreterPath)" Condition="!$(BuildingForUpToDateCheck)"/>
  </Target>

  <!-- *************************************************************************
       WSGI settings are written by CreateWebConfig target. To extend the
       settings added to this file, create a target that appends to
       $(WsgiAppSettings) and add its name to the
       CreateWebConfigDependsOnTargets property.
       
       Note that if the user includes a web.config file in their project, no
       file will be generated and these targets will have no effect.
  -->
  <Target Name="ResolveWsgiAppSettings"
          DependsOnTargets="ResolvePythonWsgiHandler;ResolveVirtualEnvSettings;ResolveDeploymentSettings">
    <ItemGroup>
      <_AbsoluteSearchPaths Include="$(DeployedSiteRoot)" />
      <_SearchPaths Include="$(WorkingDirectory)" Condition="'$(WorkingDirectory)' != '' and '$(WorkingDirectory)' != '.'" />
      <_SearchPaths Include="$(SearchPath)" Condition="'$(SearchPath)' != ''" />
    </ItemGroup>
    <CombinePath BasePath="$(DeployedSiteRoot)" Paths="@(_SearchPaths)" Condition="'@(_SearchPaths)' != ''">
      <Output TaskParameter="CombinedPaths" ItemName="_AbsoluteSearchPaths"/>
    </CombinePath>
    <PropertyGroup>
      <WsgiAppSettings>
        <![CDATA[$(WsgiAppSettings)
    <add key="WSGI_HANDLER" value="$(PythonWsgiHandler)"/>
    <add key="$(PythonPathEnvironmentVariable)" value="@(_AbsoluteSearchPaths->'%(Identity)', '%3b')"/>]]>
      </WsgiAppSettings>
      <WsgiAppSettings Condition="'$(WsgiLogPath)' != ''">
        <![CDATA[$(WsgiAppSettings)
    <add key="WSGI_LOG" value="$(WsgiLogPath)"/>]]>
      </WsgiAppSettings>
    </PropertyGroup>
  </Target>

  <!-- *************************************************************************
       The FastCGI handler is written out in the CreateWebConfig target. To
       replace the handler, this target should be redefined.
  -->
  <Target Name="ResolveFastCgiHandler"
          DependsOnTargets="ResolveDeploymentSettings">
    <PropertyGroup>
      <FastCgiHandler Condition="'$(FastCgiHandler)' == ''">
        <![CDATA[<add name="Python FastCGI"
             path="handler.fcgi"
             verb="*"
             modules="FastCgiModule"
             scriptProcessor="$(DeployedPythonInterpreterPath)|$(DeployedWFastCgiPath)"
             resourceType="Unspecified"
             requireAccess="Script" />]]>
      </FastCgiHandler>
    </PropertyGroup>
  </Target>

  <!-- *************************************************************************
       The static URI pattern is added as a condition to the rewrite that
       directs requests to WFastCGI. URIs that match the pattern will be
       resolved to a file system path.
  -->
  
  <Target Name="AddStaticUriSetting"
          Condition="'$(StaticUriPattern)' != ''">
    <ValidateRegexPattern Pattern="$(StaticUriPattern)"
                          Message="Invalid static URI pattern: {0}" />
    
    <PropertyGroup>
      <FastCgiRewriteConditions>
        <![CDATA[$(FastCgiRewriteConditions)
            <add input="{REQUEST_URI}" pattern="$(StaticUriPattern)" ignoreCase="true" negate="true"/>]]>
      </FastCgiRewriteConditions>
    </PropertyGroup>
  </Target>
  
  <!-- *************************************************************************
       Virtual environments are handled in three targets.
       
       ConfigureVirtualEnv is part of generating WSGI settings for web.config.
       
       CollectVirtualEnvFiles will convert a virtual environment into deployable
       Content.
  -->
  <Target Name="ResolveVirtualEnvSettings" DependsOnTargets="ResolvePythonInterpreterPath;_ResolveVirtualEnvSettings" />

  <Target Name="_GetPythonVirtualEnvProxyForEmulator"
          Condition="'$(_PythonDeploymentMethod)' == 'CloudServiceDeploy'">
    <ItemGroup Condition="$(VirtualEnvEnabled)">
      <_PythonVirtualEnvProxyForEmulator Include="$(QualifiedProjectHome)ptvs_virtualenv_proxy.py">
        <SourceFile>$(_AzureSupportPath)ptvs_virtualenv_proxy.py</SourceFile>
      </_PythonVirtualEnvProxyForEmulator>
    </ItemGroup>
  </Target>

  <Target Name="_ResolveVirtualEnvSettings"
          DependsOnTargets="ResolvePythonWsgiHandler;ResolveDeploymentSettings;_GetPythonVirtualEnvProxyForEmulator"
          Condition="$(VirtualEnvEnabled)">
    <Error Text="No WSGI handler specified" Condition="'$(PythonWsgiHandler)' == ''" />

    <PropertyGroup>
      <!-- Setup for when a virtualenv is used in a project. We use a bootstrap
           wfastcgi handler which does activate_this on the deployed env. -->
      <DeployedVirtualEnvPath Condition="'$(DeployedVirtualEnvPath)' == ''">$(DeployedSiteRoot)</DeployedVirtualEnvPath>
      <DeployedVirtualEnvPath Condition="!HasTrailingSlash('$(DeployedVirtualEnvPath)')">$(DeployedVirtualEnvPath)\</DeployedVirtualEnvPath>
      <WsgiAppSettings>
        <![CDATA[$(WsgiAppSettings)
    <add key="WSGI_ALT_VIRTUALENV_HANDLER" value="$(PythonWsgiHandler)"/>]]>
      </WsgiAppSettings>
      <WsgiAppSettings Condition="!$(VirtualEnvIsVEnv)">
        <![CDATA[$(WsgiAppSettings)
    <add key="WSGI_ALT_VIRTUALENV_ACTIVATE_THIS" value="$(DeployedVirtualEnvPath)$(PythonPrefixSubPath)Scripts\activate_this.py"/>]]>
      </WsgiAppSettings>
      <WsgiAppSettings Condition="$(VirtualEnvIsVEnv)">
        <![CDATA[$(WsgiAppSettings)
    <add key="WSGI_ALT_VIRTUALENV_ACTIVATE_THIS" value="$(DeployedVirtualEnvPath)$(PythonPrefixSubPath)$([msbuild]::MakeRelative($(PythonPrefixPath), $(PythonInterpreterPath)))"/>]]>
      </WsgiAppSettings>
      <PythonWsgiHandler Condition="!$(VirtualEnvIsVEnv)">ptvs_virtualenv_proxy.get_virtualenv_handler()</PythonWsgiHandler>
      <PythonWsgiHandler Condition="$(VirtualEnvIsVEnv)">ptvs_virtualenv_proxy.get_venv_handler()</PythonWsgiHandler>
    </PropertyGroup>

    <!-- ptvs_virtualenv_proxy.py runs virtualenv's activate_this.py and then
         returns the real FastCGI handler. This enables running on systems where
         we need to execute using the system Python interpreter.
    -->
    <ItemGroup>
      <FilesForPackagingFromProject Include="$(_AzureSupportPath)ptvs_virtualenv_proxy.py">
        <DestinationRelativePath>ptvs_virtualenv_proxy.py</DestinationRelativePath>
        <FromTarget>ResolveVirtualEnvSettings</FromTarget>
        <Category>Run</Category>
      </FilesForPackagingFromProject>
    </ItemGroup>
  </Target>

  <Target Name="CollectVirtualEnvFiles" DependsOnTargets="ResolvePythonInterpreterPath;_CollectVirtualEnvFiles;_CollectVEnvFiles" />

  <Target Name="_CollectVirtualEnvFiles"
          DependsOnTargets="ResolveVirtualEnvSettings"
          Condition="!$(VirtualEnvIsVenv)">
    <Error Text="Should not be invoked during up-to-date check" Condition="$(BuildingForUpToDateCheck)" />

    <PropertyGroup>
      <OrigPrefixPath>$(IntermediateOutputPath)deployment-updated-orig-prefix.txt</OrigPrefixPath>
      <TargetPythonPrefix Condition="$(TargetPythonPrefix) == ''">D:\Python$(PythonMajorVersion)$(PythonMinorVersion)</TargetPythonPrefix>
    </PropertyGroup>

    <ReadLinesFromFile File="$(OrigPrefixPath)" Condition="Exists($(OrigPrefixPath))">
      <Output TaskParameter="Lines" PropertyName="_ExistingPrefixText"/>
    </ReadLinesFromFile>

    <WriteLinesToFile Lines="$(TargetPythonPrefix)"
                      File="$(OrigPrefixPath)"
                      Overwrite="true"
                      Condition="'$(_ExistingPrefixText)' != '$(TargetPythonPrefix)' "/>

    <ItemGroup>
      <FileWrites Include="$(OrigPrefixPath)" />
      
      <!-- Include all the virtual env files (except cached bytecode and
           completion DBs), and replace the orig-prefix.txt file with our
           rewritten version.
      -->
      <_VirtualEnvFilesWithoutMetadata Include="$(PythonPrefixSubPath)**\*"
        Exclude="$(PythonPrefixSubPath)Lib\orig-prefix.txt;
                 $(PythonPrefixSubPath).ptvs\**\*;
                 $(PythonPrefixSubPath)**\*.pyc;
                 $(PythonPrefixSubPath)**\*.pyo" />

      <FilesForPackagingFromProject Include="@(_VirtualEnvFilesWithoutMetadata)">
        <DestinationRelativePath>$(PythonPrefixSubPath)%(RecursiveDir)%(Filename)%(Extension)</DestinationRelativePath>
        <FromTarget>CollectVirtualEnvFiles</FromTarget>
        <Category>Run</Category>
      </FilesForPackagingFromProject>

      <FilesForPackagingFromProject Include="$(OrigPrefixPath)">
        <DestinationRelativePath>$(PythonPrefixSubPath)Lib\orig-prefix.txt</DestinationRelativePath>
        <FromTarget>CollectVirtualEnvFiles</FromTarget>
        <Category>Run</Category>
      </FilesForPackagingFromProject>
    </ItemGroup>
  </Target>

  <Target Name="_CollectVEnvFiles"
          DependsOnTargets="ResolvePythonInterpreterPath"
          Condition="$(VirtualEnvIsVenv)">
    <Error Text="Should not be invoked during up-to-date check" Condition="$(BuildingForUpToDateCheck)" />

    <PropertyGroup>
      <PyVEnvCfg>$(IntermediateOutputPath)deployment-updated-pyvenv.cfg</PyVEnvCfg>
      <_ExistingCfgText Condition="Exists($(PyVEnvCfg))">$([System.IO.File]::ReadAllText($(PyVEnvCfg)))</_ExistingCfgText>
      
      <TargetPythonPrefix Condition="$(TargetPythonPrefix) == ''">D:\Python$(PythonMajorVersion)$(PythonMinorVersion)</TargetPythonPrefix>
      <_PyVEnvCfgText>$([System.Text.RegularExpressions.Regex]::Replace(
        $([System.IO.File]::ReadAllText(`$(PythonPrefixSubPath)pyvenv.cfg`)),
        `(home\s*=\s*)[^\r\n]+`,
        `$1$(TargetPythonPrefix)`)
      )</_PyVEnvCfgText>
    </PropertyGroup>

    <WriteLinesToFile Lines="$(_PyVEnvCfgText)"
                      File="$(PyVEnvCfg)"
                      Overwrite="true"
                      Condition="'$(_ExistingCfgText)' != '$(_PyVEnvCfgText)' "/>

    <ItemGroup>
      <FileWrites Include="$(PyVEnvCfg)" />
      
      <!-- Include all the virtual env files (except cached bytecode and
           completion DBs), and replace the orig-prefix.txt file with our
           rewritten version.
      -->
      <_VirtualEnvFilesWithoutMetadata Include="$(PythonPrefixSubPath)**\*"
        Exclude="$(PythonPrefixSubPath)pyvenv.cfg;
                 $(PythonPrefixSubPath).ptvs\**\*;
                 $(PythonPrefixSubPath)**\*.pyc;
                 $(PythonPrefixSubPath)**\*.pyo" />

      <FilesForPackagingFromProject Include="@(_VirtualEnvFilesWithoutMetadata)">
        <DestinationRelativePath>$(PythonPrefixSubPath)%(RecursiveDir)%(Filename)%(Extension)</DestinationRelativePath>
        <FromTarget>CollectVEnvFiles</FromTarget>
        <Category>Run</Category>
      </FilesForPackagingFromProject>

      <FilesForPackagingFromProject Include="$(PyVEnvCfg)">
        <DestinationRelativePath>$(PythonPrefixSubPath)pyvenv.cfg</DestinationRelativePath>
        <FromTarget>CollectVEnvFiles</FromTarget>
        <Category>Run</Category>
      </FilesForPackagingFromProject>
    </ItemGroup>
  </Target>

  <!-- *************************************************************************
       CollectPythonWebSitesFiles deploys and includes extra files required for
       Microsoft Azure Web Sites.
  -->
  <ItemGroup>
    <!--<_WebSitesFiles />-->
  </ItemGroup>

  <Target Name="CollectPythonWebSitesFiles"
          DependsOnTargets="ResolvePythonDeploymentMethod;_CollectPythonWebSitesFiles"
          Condition="'@(_WebSitesFiles)' != ''"/>

  <Target Name="_GetPythonWebSitesFiles"
          Returns="@(_PythonWebSitesFiles)"
          Condition="'$(_PythonDeploymentMethod)' == 'WebDeploy'">
    <ItemGroup>
      <_PythonWebSitesFiles Include="@(_WebSitesFiles->'$(IntermediateOutputPath)%(Filename)%(Extension)')">
        <SourceFile>%(FullPath)</SourceFile>
      </_PythonWebSitesFiles>
    </ItemGroup>
  </Target>

  <Target Name="_CollectPythonWebSitesFiles"
          Inputs="@(_WebSitesFiles)"
          Outputs="@(_PythonWebSitesFiles)"
          DependsOnTargets="_GetPythonWebSitesFiles"
          Condition="'$(_PythonDeploymentMethod)' == 'WebDeploy'">
    <Error Text="Should not be invoked during up-to-date check" Condition="$(BuildingForUpToDateCheck)" />

    <Copy SourceFiles="@(_WebSitesFiles)"
          DestinationFiles="@(_PythonWebSitesFiles)"
          SkipUnchangedFiles="true">
      <Output TaskParameter="CopiedFiles" ItemName="FileWrites"/>
    </Copy>

    <ItemGroup>
      <FilesForPackagingFromProject Include="@(_PythonWebSitesFiles->'%(FullPath)')">
        <DestinationRelativePath>%(FileName)%(Extension)</DestinationRelativePath>
        <FromTarget>CollectPythonWebSitesFiles</FromTarget>
        <Category>Run</Category>
      </FilesForPackagingFromProject>
    </ItemGroup>
  </Target>

  <!-- *************************************************************************
       CollectPythonCloudServiceFiles deploys extra files for cloud services.
       
       These files are copied to the intermediate path on build.
       
       When building inside VS (for the emulator), the directory of the item
       returned from the GetTargetPath target is copied to the approot\bin
       directory. We also copy them to $(QualifiedProjectHome)\bin, since that
       is where AzureSetup.exe expects to find them.
       
       When building outside VS (for publishing), the PipelineTransformPhase
       target will add these files as content with a link to "bin\$(name)" to
       ensure they are deployed to approot\bin.
  -->
  <ItemGroup>
    <!-- Azure setup files -->
    <_CloudServiceFiles Include="$(_AzureSupportPath)Microsoft.PythonTools.AzureSetup.exe;
                                 $(_AzureSupportPath)Microsoft.PythonTools.AzureSetup.exe.config"/>
    <_CloudServiceFiles Include="$(_AzureSupportPath)Microsoft.PythonTools.AzureSetup.pdb"
                        Condition="Exists('$(_AzureSupportPath)Microsoft.PythonTools.AzureSetup.pdb')" />

    <!-- WebPI deployment files -->
    <_CloudServiceFiles Include="$(_WebPISupportPath)WebPICmdLine.exe;
                                 $(_WebPISupportPath)WebPICmdLine.exe.config;
                                 $(_WebPISupportPath)Microsoft.Web.PlatformInstaller.UI.dll;
                                 $(_WebPISupportPath)Microsoft.Web.PlatformInstaller.dll;
                                 $(_WebPISupportPath)Microsoft.Web.Deployment.dll" />

    <!-- Web Role files -->
    <_CloudServiceFiles Include="$(_AzureSupportPath)Microsoft.PythonTools.WebRole.dll" />

    <!-- FastCGI handler -->
    <_CloudServiceFiles Include="$(_AzureSupportPath)wfastcgi.py" />
  </ItemGroup>

  <Target Name="CollectPythonCloudServiceFiles"
          DependsOnTargets="ResolvePythonDeploymentMethod;
                            CreatePythonAzureSetupConfig;
                            _DeployPythonCloudServiceFiles;
                            _DeployPythonCloudServiceFilesForEmulator;
                            _CollectPythonCloudServiceFiles"
          Condition="'@(_CloudServiceFiles)' != ''"/>

  <Target Name="_GetPythonCloudServiceFiles"
          Returns="@(_PythonCloudServiceFiles);@(_PythonCloudServiceFilesForEmulator)"
          Condition="'$(_PythonDeploymentMethod)' == 'CloudServiceDeploy'">
    <ItemGroup>
      <_PythonCloudServiceFiles Include="@(_CloudServiceFiles->'$(IntermediateOutputPath)%(Filename)%(Extension)')">
        <SourceFile>%(FullPath)</SourceFile>
      </_PythonCloudServiceFiles>
      <_PythonCloudServiceFilesForEmulator Include="@(_CloudServiceFiles->'$(QualifiedProjectHome)bin\%(Filename)%(Extension)')">
        <SourceFile>%(FullPath)</SourceFile>
      </_PythonCloudServiceFilesForEmulator>
    </ItemGroup>
  </Target>

  <Target Name="_DeployPythonCloudServiceFiles"
          Inputs="@(_CloudServiceFiles)"
          Outputs="@(_PythonCloudServiceFiles)"
          DependsOnTargets="_GetPythonCloudServiceFiles"
          Condition="'$(_PythonDeploymentMethod)' == 'CloudServiceDeploy'">
    <Error Text="Should not be invoked during up-to-date check" Condition="$(BuildingForUpToDateCheck)" />

    <Copy SourceFiles="@(_CloudServiceFiles)"
          DestinationFiles="@(_PythonCloudServiceFiles)"
          SkipUnchangedFiles="true">
      <Output TaskParameter="CopiedFiles" ItemName="FileWrites"/>
    </Copy>
  </Target>

  <Target Name="_DeployPythonCloudServiceFilesForEmulator"
          Inputs="@(_CloudServiceFiles)"
          Outputs="@(_PythonCloudServiceFilesForEmulator)"
          DependsOnTargets="_GetPythonCloudServiceFiles;_GetPythonVirtualEnvProxyForEmulator"
          Condition="'$(_PythonDeploymentMethod)' == 'CloudServiceDeploy'">
    <Error Text="Should not be invoked during up-to-date check" Condition="$(BuildingForUpToDateCheck)" />

    <Copy SourceFiles="@(_CloudServiceFiles)"
          DestinationFiles="@(_PythonCloudServiceFilesForEmulator)"
          SkipUnchangedFiles="true">
      <Output TaskParameter="CopiedFiles" ItemName="FileWrites"/>
    </Copy>
    
    <!-- Copy the proxy script to the bin\ directory for the Cloud Service
         emulator. -->
    <Copy SourceFiles="$(_AzureSupportPath)ptvs_virtualenv_proxy.py"
          DestinationFiles="@(_PythonVirtualEnvProxyForEmulator)"
          SkipUnchangedFiles="true"
          Condition="'@(_PythonVirtualEnvProxyForEmulator)' != ''">
      <Output TaskParameter="CopiedFiles" ItemName="FileWrites"/>
    </Copy>
  </Target>

  <Target Name="_CollectPythonCloudServiceFiles"
          DependsOnTargets="_GetPythonCloudServiceFiles"
          Condition="'$(_PythonDeploymentMethod)' == 'CloudServiceDeploy'">
    <ItemGroup>
      <FilesForPackagingFromProject Include="@(_PythonCloudServiceFiles)">
        <DestinationRelativePath>bin\%(FileName)%(Extension)</DestinationRelativePath>
        <FromTarget>CollectPythonCloudServiceFiles</FromTarget>
        <Category>Run</Category>
      </FilesForPackagingFromProject>
    </ItemGroup>
  </Target>

  <!-- *************************************************************************
       CreatePythonAzureSetupConfig generates the AzureSetup.cfg used for cloud
       service deployments.
  -->
  <PropertyGroup>
    <CreatePythonAzureSetupConfigDependsOnTargets>
      ResolvePythonInterpreterPath;
      ResolvePythonDeploymentMethod;
      _EnsurePython27WebPiReference;
      _ValidatePythonVersion
    </CreatePythonAzureSetupConfigDependsOnTargets>

    <!-- This property should be set to true if WebPI references should not be
         added for cloud service deployments. -->
    <SuppressGenerateWebPiReference Condition="'$(SuppressGenerateWebPiReference)' != 'true'">false</SuppressGenerateWebPiReference>
  </PropertyGroup>

  <ItemGroup>
    <!-- This item group is added to WebPiReference if the active environment is 2.7 -->
    <_Python27WebPiReference Include="https://www.microsoft.com/web/webpi/4.0/toolsproductlist.xml%3fPython27">
      <Feed>https://www.microsoft.com/web/webpi/4.0/toolsproductlist.xml</Feed>
      <ProductId>Python27</ProductId>
      <FriendlyName>Python 2.7</FriendlyName>
    </_Python27WebPiReference>
    <_Python27WebPiReferenceIncompatibilities Include="https://www.microsoft.com/web/webpi/3.0/toolsproductlist.xml%3fPython27" />
  </ItemGroup>

  <Target Name="CreatePythonAzureSetupConfig" DependsOnTargets="$(CreatePythonAzureSetupConfigDependsOnTargets);_CreatePythonAzureSetupConfig" />

  <Target Name="_GetPythonAzureSetupConfigOutput"
          Condition="'$(_PythonDeploymentMethod)' == 'CloudServiceDeploy'">
    <ItemGroup>
      <_PythonAzureSetupConfig Include="$(IntermediateOutputPath)AzureSetup.cfg" />
      <_PythonAzureSetupConfigForEmulator Include="$(QualifiedProjectHome)bin\AzureSetup.cfg" />
      <_PythonAzureSetupConfigOutput Include="@(_PythonAzureSetupConfig);@(_PythonAzureSetupConfigForEmulator)" />
    </ItemGroup>
  </Target>

  <Target Name="_ValidatePythonVersion"
          Condition="!$(SuppressGenerateWebPiReference) and '@(WebPiReference)' == ''"
          DependsOnTargets="_EnsurePython27WebPiReference">
    <Warning Text="$(PythonInterpreterDescription) is not natively supported on Microsoft Azure. Add a WebPI reference to install this environment or add the 'SuppressGenerateWebPiReference' property to $(MSBuildProjectName) and set it to true." />
  </Target>
  
  <Target Name="_EnsurePython27WebPiReference"
          Condition="!$(SuppressGenerateWebPiReference) and $(PythonVersion) == '2.7' and $(PythonArchitecture) == 'x86'">
    <ItemGroup>
      <_FilteredWebPiReference Remove="@(_FilteredWebPiReference)" />
    </ItemGroup>
    <RemoveDuplicates Inputs="@(WebPiReference);@(_Python27WebPiReference)">
      <Output TaskParameter="Filtered" ItemName="_FilteredWebPiReference"/>
    </RemoveDuplicates>
    <ItemGroup>
      <WebPiReference Remove="@(WebPiReference)" />
      <WebPiReference Include="@(_FilteredWebPiReference)" Exclude="@(_Python27WebPiReferenceIncompatibilities)" />
    </ItemGroup>
  </Target>

  <Target Name="_CreatePythonAzureSetupConfig"
          DependsOnTargets="ResolvePythonInterpreterPath;_GetPythonAzureSetupConfigOutput"
          Condition="'$(_PythonDeploymentMethod)' == 'CloudServiceDeploy'">
    <Error Text="Should not be invoked during up-to-date check" Condition="$(BuildingForUpToDateCheck)" />

    <PropertyGroup>
      <!-- AzureSetup.cfg variables are written out here so we can switch on
           them in AzureSetup.exe based upon whether we're emulated or not.
      -->
      <_CloudServiceAzureSetupConfig>
        <![CDATA[
interpreter_path=%SystemDrive%\Python$(PythonMajorVersion)$(PythonMinorVersion)\python.exe
interpreter_path_emulated=$(PythonInterpreterPath)
]]>
      </_CloudServiceAzureSetupConfig>
    </PropertyGroup>

    <WriteLinesToFile File="@(_PythonAzureSetupConfig)"
                      Lines="$(_CloudServiceAzureSetupConfig)"
                      Overwrite="true" />
    <WriteLinesToFile File="@(_PythonAzureSetupConfig)"
                      Lines="@(WebPiReference->'webpi_install=%(Feed);%(ProductId)')"
                      Overwrite="false" />

    <Copy SourceFiles="@(_PythonAzureSetupConfig)"
          DestinationFiles="@(_PythonAzureSetupConfigForEmulator)" />

    <ItemGroup>
      <FileWrites Include="@(_PythonAzureSetupConfigOutput)" />

      <FilesForPackagingFromProject Include="@(_PythonAzureSetupConfig)">
        <DestinationRelativePath>bin\%(FileName)%(Extension)</DestinationRelativePath>
        <FromTarget>CreatePythonAzureSetupConfig</FromTarget>
        <Category>Run</Category>
      </FilesForPackagingFromProject>
    </ItemGroup>
  </Target>


  <!-- *************************************************************************
       CreateWebConfig will generate a web.config file if the project does not
       specify one as a <Content> or <Include> item.
  -->
  <PropertyGroup>
    <CreateWebConfigDependsOnTargets>
      $(CreateWebConfigDependsOnTargets);
      ResolvePythonInterpreterPath;
      ResolvePythonWsgiHandler;
      ResolveFastCgiHandler;
      AddStaticUriSetting;
      ResolveDeploymentSettings;
      ResolveWsgiAppSettings;
      ResolveVirtualEnvSettings;
    </CreateWebConfigDependsOnTargets>

    <AlwaysRegenerateWebConfig Condition="'$(AlwaysRegenerateWebConfig)' == ''">false</AlwaysRegenerateWebConfig>
  </PropertyGroup>

  <Target Name="CreateWebConfig" DependsOnTargets="_DetectWebConfig;_CreateWebConfig" />

  <Target Name="_DetectWebConfig">
    <ItemGroup>
      <_OutWebConfig Include="$(QualifiedProjectHome)web.config"/>
      <_WebConfigInContent Include="@(Content)" Condition="'%(Content.Identity)' == 'web.config'" />
    </ItemGroup>

    <ReadLinesFromFile File="@(_OutWebConfig)" Condition="Exists('@(_OutWebConfig)')">
      <Output TaskParameter="Lines" PropertyName="_CurrentWebConfigCode"/>
    </ReadLinesFromFile>

    <PropertyGroup>
      <_RegenerateWebConfig>true</_RegenerateWebConfig>
      <_RegenerateWebConfig Condition="Exists('@(_OutWebConfig)') and !$(AlwaysRegenerateWebConfig) and
          !$(_CurrentWebConfigCode.Contains('Generated web.config for Windows Azure.')) and
          !$(_CurrentWebConfigCode.Contains('Generated web.config for Microsoft Azure.'))">false</_RegenerateWebConfig>
    </PropertyGroup>

    <Message Text="Using existing web.config file" Condition="!$(_RegenerateWebConfig) and !$(BuildingForUpToDateCheck)"/>
  </Target>

  <Target Name="_CreateWebConfig"
          DependsOnTargets="$(CreateWebConfigDependsOnTargets)"
          Condition="$(_RegenerateWebConfig)">
    <Message Text="Regenerating web.config" />
    <Error Text="Should not be invoked during up-to-date check" Condition="$(BuildingForUpToDateCheck)" />
    <Error Text="No WSGI handler specified" Condition="'$(PythonWsgiHandler)' == ''" />

    <ItemGroup>
      <_TempWebConfig Include="$(IntermediateOutputPath)web.config" />
    </ItemGroup>

    <Copy SourceFiles="$(_AzureSupportPath)web_config.xml"
          DestinationFiles="@(_TempWebConfig)">
      <Output TaskParameter="CopiedFiles" ItemName="FileWrites"/>
    </Copy>

    <Message Text="Updating app settings in web.config" />
    <XmlPoke XmlInputPath="@(_TempWebConfig)"
             Query="/configuration/appSettings"
             Value="$(WsgiAppSettings)" />

    <Message Text="Updating rewrite conditions in web.config" />
    <XmlPoke XmlInputPath="@(_TempWebConfig)"
             Query="/configuration/system.webServer/rewrite/rules/rule[@name='Configure Python']/conditions"
             Value="$(FastCgiRewriteConditions)"
             Condition="'$(FastCgiRewriteConditions)' != ''"/>

    <Message Text="Updating FastCGI handlers in web.config" />
    <XmlPoke XmlInputPath="@(_TempWebConfig)"
             Query="/configuration/system.webServer/handlers"
             Value="$(FastCgiHandler)" />

    <Copy SourceFiles="@(_TempWebConfig)" DestinationFiles="@(_OutWebConfig)" />

    <Delete Files="@(_TempWebConfig)" Condition="'$(BuildingForGetTargetPath)' == 'True'" />

    <ItemGroup>
      <FilesForPackagingFromProject Include="web.config" Condition="'@(_WebConfigInContent)' == ''">
        <DestinationRelativePath>web.config</DestinationRelativePath>
        <FromTarget>CreateWebConfig</FromTarget>
        <Category>Run</Category>
      </FilesForPackagingFromProject>
    </ItemGroup>
  </Target>

  <!-- *************************************************************************
       GetTargetPath is invoked by Microsoft.WindowsAzure.targets when it is
       collecting web role files. It returns one item that is our WebRole.dll.
  -->
  <Target Name="GetTargetPath" Returns="$(_WebRoleDll)"
          DependsOnTargets="ResolvePythonDeploymentMethod;
                            CreatePythonAzureSetupConfig;
                            _DeployPythonCloudServiceFiles;
                            _DeployPythonCloudServiceFilesForEmulator">
    <!-- We need to build CreateWebConfig in a separate instance. This will
         ensure that the web.config file exists for the Cloud Service emulator,
         while also allowing us to rebuild it later if we determine that we
         really wanted a Web Sites web.config.
         
         The DependsOnTargets attribute is not useful here, since running the
         targets that way will prevent us from reevaluating them later in the
         same build.
    -->
    <MSBuild Projects="$(MSBuildProjectFullPath)"
             Targets="CreateWebConfig"
             Properties="BuildingForGetTargetPath=true" />

    <PropertyGroup>
      <_WebRoleDll>$([System.IO.Path]::GetFullPath('$(IntermediateOutputPath)Microsoft.PythonTools.WebRole.dll'))</_WebRoleDll>
    </PropertyGroup>
  </Target>

  <Target Name="PrepareForBuild">
    <MakeDir Directories="$(OutDir);$(IntermediateOutputPath);@(CreateDirectory)" ContinueOnError="True"/>
  </Target>


  <!-- *************************************************************************
       Web commands. These are displayed to the user in the PTVS IDE and are
       used by the web launcher.
  -->
  <PropertyGroup>
    <WebServerHost Condition="'$(WebServerHost)' == ''">localhost</WebServerHost>
    <PythonCommands>$(PythonCommands);PythonRunWebServerCommand;PythonDebugWebServerCommand</PythonCommands>
    <PythonCommands Condition="'$(PythonWebFrameworkPackage)' != ''">$(PythonCommands);PythonUpgradeWebFrameworkCommand</PythonCommands>
    <PythonWebFrameworkPackageDisplayName Condition="'$(PythonWebFrameworkPackageDisplayName)' == ''">framework</PythonWebFrameworkPackageDisplayName>
  </PropertyGroup>

  <Target Name="PythonRunWebServerCommand"
          Label="resource:Microsoft.PythonTools;Microsoft.PythonTools.Resources;RunWebServerLabel"
          Returns="@(Commands)">
    <PropertyGroup>
      <PythonRunWebServerCommand Condition="'$(PythonRunWebServerCommand)' == ''">$(StartupPath)</PythonRunWebServerCommand>
      <PythonRunWebServerCommandType Condition="'$(PythonRunWebServerCommandType)' == ''">script</PythonRunWebServerCommandType>
      <PythonRunWebServerCommandArguments Condition="'$(PythonRunWebServerCommandArguments)' == ''">$(CommandLineArguments)</PythonRunWebServerCommandArguments>
      <PythonRunWebServerCommandEnvironment>
        SERVER_HOST=$(WebServerHost)
        SERVER_PORT=$(WebBrowserPort)
        $(PythonRunWebServerCommandEnvironment)
      </PythonRunWebServerCommandEnvironment>
      
      <PythonRunWebServerCommand>$(PythonRunWebServerCommand.Replace(`{StartupModule}`, $(StartupModule)))</PythonRunWebServerCommand>
      <PythonRunWebServerCommandArguments>$(PythonRunWebServerCommandArguments.Replace(`{StartupModule}`, $(StartupModule)))</PythonRunWebServerCommandArguments>
      <PythonRunWebServerArguments>$(PythonRunWebServerArguments.Replace(`{StartupModule}`, $(StartupModule)))</PythonRunWebServerArguments>
      <PythonRunWebServerCommandEnvironment>$(PythonRunWebServerCommandEnvironment.Replace(`{StartupModule}`, $(StartupModule)))</PythonRunWebServerCommandEnvironment>
    </PropertyGroup>
    <!-- 'console' and 'consolepause' are the only valid ExecuteIn values for this command. -->
    <CreatePythonCommandItem Target="$(PythonRunWebServerCommand)"
                             TargetType="$(PythonRunWebServerCommandType)"
                             Arguments="$(PythonRunWebServerCommandArguments)"
                             Environment="$(PythonRunWebServerCommandEnvironment)"
                             WorkingDirectory="$(WorkingDirectory)"
                             ExecuteIn="console">
      <Output TaskParameter="Command" ItemName="Commands" />
    </CreatePythonCommandItem>
  </Target>

  <Target Name="PythonDebugWebServerCommand"
          Label="resource:Microsoft.PythonTools;Microsoft.PythonTools.Resources;DebugWebServerLabel"
          Returns="@(Commands)">
    <PropertyGroup>
      <PythonDebugWebServerCommand Condition="'$(PythonDebugWebServerCommand)' == ''">$(StartupPath)</PythonDebugWebServerCommand>
      <PythonDebugWebServerCommandType Condition="'$(PythonDebugWebServerCommandType)' == ''">script</PythonDebugWebServerCommandType>
      <PythonDebugWebServerCommandArguments Condition="'$(PythonDebugWebServerCommandArguments)' == ''">$(CommandLineArguments)</PythonDebugWebServerCommandArguments>
      <PythonDebugWebServerCommandEnvironment>
        SERVER_HOST=$(WebServerHost)
        SERVER_PORT=$(WebBrowserPort)
        $(PythonDebugWebServerCommandEnvironment)
      </PythonDebugWebServerCommandEnvironment>

      <PythonDebugWebServerCommand>$(PythonDebugWebServerCommand.Replace(`{StartupModule}`, $(StartupModule)))</PythonDebugWebServerCommand>
      <PythonDebugWebServerCommandArguments>$(PythonDebugWebServerCommandArguments.Replace(`{StartupModule}`, $(StartupModule)))</PythonDebugWebServerCommandArguments>
      <PythonDebugWebServerArguments>$(PythonDebugWebServerArguments.Replace(`{StartupModule}`, $(StartupModule)))</PythonDebugWebServerArguments>
      <PythonDebugWebServerCommandEnvironment>$(PythonDebugWebServerCommandEnvironment.Replace(`{StartupModule}`, $(StartupModule)))</PythonDebugWebServerCommandEnvironment>
    </PropertyGroup>
    <!-- 'console' and 'consolepause' are the only valid ExecuteIn values for this command. -->
    <CreatePythonCommandItem Target="$(PythonDebugWebServerCommand)"
                             TargetType="$(PythonDebugWebServerCommandType)"
                             Arguments="$(PythonDebugWebServerCommandArguments)"
                             Environment="$(PythonDebugWebServerCommandEnvironment)"
                             WorkingDirectory="$(WorkingDirectory)"
                             ExecuteIn="console">
      <Output TaskParameter="Command" ItemName="Commands" />
    </CreatePythonCommandItem>
  </Target>

  <Target Name="PythonUpgradeWebFrameworkCommand"
          Label="resource:Microsoft.PythonTools;Microsoft.PythonTools.Resources;UpgradeWebFrameworkLabel"
          Returns="@(Commands)">
    <!-- 'pip' is a special TargetType that will also install pip if required. -->
    <CreatePythonCommandItem Target="$(PythonWebFrameworkPackage)"
                             TargetType="pip"
                             Arguments="--upgrade"
                             ExecuteIn="output">
      <Output TaskParameter="Command" ItemName="Commands" />
    </CreatePythonCommandItem>
  </Target>
</Project>
